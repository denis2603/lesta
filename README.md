Тестовое задание от Lesta Studio
================================

Задание 1.
----------
**На языке Python реализовать алгоритм (функцию) определения четности целого числа, который будет аналогичен нижеприведенному по функциональности, но отличен по своей сути. Объяснить плюсы и минусы обеих реализаций.**

Python example:
```python
    def isEven(value):return value%2==0
```

Решение:
```python
def is_even_fast(value: int) -> bool:
    return not(value & 1)
```

Число нечетное, когда его младший бит равен 1. Побитовым "И" искомого числа и единицы получаем последний бит.
Оператор not преобразует 1 в False (число нечетное), 0 соответственно в True.

Первая реализация нагляднее и проще для понимания при чтении кода. Вторая быстрее.

Байткод функции isEven:
```commandline
  4           0 LOAD_FAST                0 (value)
              2 LOAD_CONST               1 (2)
              4 BINARY_MODULO
              6 LOAD_CONST               2 (0)
              8 COMPARE_OP               2 (==)
             10 RETURN_VALUE
```
Байткод функции is_even_fast:
```commandline
 14           0 LOAD_FAST                0 (value)
              2 LOAD_CONST               1 (1)
              4 BINARY_AND
              6 UNARY_NOT
              8 RETURN_VALUE
```
В первом случае загружается больше констант и выполняется больше операций.

Задание 2. 
----------
**На языке Python (2.7) реализовать минимум по 2 класса реализовывающих циклический буфер FIFO. Объяснить плюсы и минусы каждой реализации.**

Так как в условии не заданы параметры буфера, определим следующее:
- при инициализации буфера передается его размер.
- при попытке считывания из пустого буфера возникает исключение IndexError.
- запись в полностью заполненный буфер возможна. При этом самое старое значение переписывается новым.
При необходимости это поведение может быть переопределено.

**Реализации**
1. task2a - на базе списка, 
2. task2b - на базе очереди из встроенного модуля collections,
3. task2c - односвязный список на базе собственного класса.  

Функциональность всех решений одинаковая. Реализовано добавление элемента в буфер, извлечение последнего, строковое представление, 
изменение размера буфера, очистка буфера, получение максимального размера и занятого размера буфера.

Реализация на базе списка наименее эффективна, так как будет происходить постоянное изменение размера списка при добавлении/удалении данных. 
В то же время объект deque из модуля collection оптимизирован для добавления/удаления элементов с концов, а это основные операции в данном случае.


Задание 3. 
----------
**На языке Python реализовать функцию, которая быстрее всего (по процессорным тикам) отсортирует данный ей массив чисел. Массив может быть любого размера со случайным порядком чисел (в том числе и отсортированным). Объяснить почему вы считаете, что функция соответствует заданным критериям.**

Существую разные алгоритмы сортировки, все они достаточно хорошо описаны и реализовать конкретные не составит большой сложности.
Я выбрал алгоритм быстрой сортировки, скорость которого зависит от выбора опорного элемента на каждой итерации.
Если предположить что массивы иногда будут отсортированны (полностью или частично), то выбирая средний элемент в массиве можно получить в среднем неплохие результаты.  
